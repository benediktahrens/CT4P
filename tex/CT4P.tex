\documentclass[a4paper,11pt, oneside,titlepage=false]{scrbook}
\usepackage[utf8]{inputenc}

\usepackage{tikz-cd}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{thmtools}

%\usepackage{ntheorem}
\usepackage{stmaryrd} % texlive-science
\usepackage{verbatim}
\usepackage{ccicons}
\usepackage{enumitem}

\usepackage{bussproofs}
\newcommand{\proofskip}{0.5em}
\newcommand{\rulelabel}[1]{\hypertarget{#1}{\textsf{\scriptsize #1}}}
\newcommand{\ruleref}[1]{\hyperlink{#1}{\textsf{#1}}}
\newenvironment{bproof}
{\leavevmode\hbox\bgroup}
{\DisplayProof\egroup}
\newcommand{\binaryRule}[4]{\begin{bproof}
\AxiomC{\ensuremath{#1}}
\AxiomC{\ensuremath{#2}}
\RightLabel{\rulelabel{#4}}
\BinaryInfC{\ensuremath{#3}}
\end{bproof}\vspace{\proofskip}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newcommand{\onlydraft}[1]{} % DON'T CHANGE THIS LINE

%\renewcommand{\onlydraft}[1]{#1}  % Toggle this line to show/hide todo-notes, table of contents, etc.



\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}%to do list and comments

\newcommand{\plan}[1]{}
\newcommand{\BA}[1]{}
\newcommand{\KW}[1]{}
% \onlydraft{
%    \renewcommand{\plan}[1]{{\color{blue}{#1}}\PackageWarning{TODO}{Plan: #1}}
%    \renewcommand{\BA}[1]{\todo[color=orange!30]{BA: #1} \PackageWarning{TODO}{BA: #1}}
%    \renewcommand{\KW}[1]{\todo[color=green!30]{KW: #1}\PackageWarning{TODO}{KW: #1}}
% }

\newcommand{\issue}[1]{\href{https://github.com/benediktahrens/CT4P/issues/#1}{Issue #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[style=numeric,backend=biber]{biblatex}
\addbibresource{literature.bib}

\usepackage{listings}
\lstMakeShortInline|
\lstset{% general command to set parameter(s)
basicstyle=\small\sffamily,
% print whole listing small
keywordstyle=\color{black}\bfseries\underbar,
% underlined bold black keywords
identifierstyle=,
% nothing happens
commentstyle=\color{white}, % white comments
stringstyle=\ttfamily,
% typewriter type for strings
showstringspaces=false,
,
literate={→ }{\ARROW}1
         {∃}{\EX}1
         {∀}{\FORALL}1
         {∧}{\AND}1
         {∨}{\OR}1
         {¬}{\NOT}1
         {⊢}{\TURNSTYLE}1
         {×}{\TIMES}1
         {λ}{\LAMBDA}1
}
% no special string spaces

% \begin{comment}
% \def\lstlanguagefiles{lstlean.tex}
% \lstset{language=lean}
% \lstdefinestyle{leannocolor}{
%    basicstyle={\ttfamily},
%    identifierstyle={\ttfamily},
%    keywordstyle=[1]{\ttfamily},
%    keywordstyle=[2]{\ttfamily},
%    keywordstyle=[3]{\ttfamily},
%    stringstyle={\ttfamily},
%    commentstyle={\ttfamily}
% }
% \end{comment}


\protected\def\ARROW{\ensuremath{\to}}
\DeclareUnicodeCharacter{2192}{\ARROW}
\protected\def\EX{\ensuremath{\exists}}
\DeclareUnicodeCharacter{2203}{\EX}
\protected\def\FORALL{\ensuremath{\forall}}
\DeclareUnicodeCharacter{2200}{\FORALL}
\protected\def\AND{\ensuremath{\wedge}}
\DeclareUnicodeCharacter{2227}{\AND}
\protected\def\OR{\ensuremath{\vee}}
\DeclareUnicodeCharacter{2228}{\OR}
\protected\def\NOT{\ensuremath{\neg}}
\DeclareUnicodeCharacter{00AC}{\NOT}
\protected\def\TURNSTYLE{\ensuremath{\vdash}}
\DeclareUnicodeCharacter{22A2}{\TURNSTYLE}
\protected\def\TIMES{\ensuremath{\times}}
\DeclareUnicodeCharacter{00D7}{\TIMES}
\protected\def\LAMBDA{\ensuremath{\lambda}}
\DeclareUnicodeCharacter{03BB}{\LAMBDA}

% \usepackage{listings}
% \lstset{
%   basicstyle=\footnotesize\ttfamily,
%   breaklines=true,
%   escapechar=!,
%   literate={→ }{\ARROW}1
%            {∃}{\EX}1
%            {∀}{\FORALL}1
%            {∧}{\AND}1
%            {∨}{\OR}1
%            {¬}{\NOT}1
%            {⊢}{\TURNSTYLE}1
%            {×}{\TIMES}1
%            {λ}{\LAMBDA}1
%            ,
%   morekeywords=[1]{example, check, reduce},
%   keywordstyle=[1]{\bfseries\color{dkviolet}},
%   morekeywords=[3]{Type,Prop, variable, variables},
%   keywordstyle=[3]{\bfseries\color{dkgreen}},
%   morekeywords=[2]{assume, reduce, variable},
%   keywordstyle=[2]{\ttfamily\color{red}},
%   keywordstyle=[4]{\bfseries\color{dkblue}},
%   morekeywords=[4]{theorem, inductive,structure,def},


\usepackage{hyperref}
\usepackage[capitalize]{cleveref}



\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\crefname{thm}{theorem}{theorems}
\Crefname{thm}{Theorem}{Theorems}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lemma}[thm]{Lemma}

\newtheorem*{reading*}{Further Reading}

\theoremstyle{definition}
\newtheorem{rem}[thm]{Remark}
\newtheorem{dfn}[thm]{Definition}
\crefname{dfn}{Definition}{Definitions}
\Crefname{dfn}{Definition}{Definitions}
\newtheorem{que}[thm]{Question}
\newtheorem{exa}[thm]{Example}
\crefname{exa}{Example}{Examples}
\Crefname{exa}{Example}{Examples}
\newtheorem{exer}[thm]{Exercise}
\crefname{exer}{Exercise}{Exercises}
\Crefname{exer}{Exercises}{Exercises}
\newtheorem{app}[thm]{Application}
\newtheorem{intu}[thm]{Intuition}
\newtheorem{explanation}[thm]{Explanation}

\newtheorem{nota}[thm]{Notation}
\newtheorem{proposal}[thm]{Proposal}
\newtheorem{goal}[thm]{Goal}
\newtheorem{constr}[thm]{Construction}
\newtheorem{solution}[thm]{Solution}

% \declaretheorem[name=Solution,
% refname={theorem,theorems},
% Refname={Theorem,Theorems}]{solution}

%\Crefname{exer}{Exercise}{Exercises}
%\Crefname{solution}{Solution}{Solutions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\cfont}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\Cat}[1]{\mathcal{#1}}
\newcommand{\CC}{\Cat{C}}
\newcommand{\DD}{\Cat{D}}
\newcommand{\EE}{\Cat{E}}
\newcommand{\Catb}[1]{\mathbf{#1}}
\newcommand{\List}{\Catb{List}}
\newcommand{\BinTree}{\Catb{BinTree}}
\newcommand{\Maybe}{\Catb{Maybe}}
\newcommand{\SET}{\Catb{Set}}
\newcommand{\PTSET}{\Catb{PtSet}}
\newcommand{\FINSET}{\Catb{FinSet}}
\newcommand{\CAT}{\Catb{Cat}}
\newcommand{\POS}{\Catb{Pos}}
\newcommand{\PRE}{\Catb{Pre}}
\newcommand{\PREtoCAT}{\Catb{Pre2Cat}}
\newcommand{\MONtoCAT}{\Catb{Mon2Cat}}
\newcommand{\MON}{\Catb{Mon}}
\newcommand{\HASK}{\Catb{Hask}}
\newcommand{\LEAN}{\Catb{LEAN}}
\newcommand{\COQ}{\Catb{Coq}}
\newcommand{\MAT}{\Catb{Mat}}
\newcommand{\SKELFINSET}{\Catb{Fin}}
\newcommand{\REL}{\Catb{Rel}}
\newcommand{\ALG}[1]{\Cat{A}lg(#1)}
\newcommand{\COALG}[1]{\Cat{C}o\Cat{A}lg(#1)}
\newcommand{\Ob}[1]{{#1}_0}
\newcommand{\Hom}[3][]{\cfont{hom}_{#1}(#2,#3)}
\newcommand{\CHom}[3]{{#1}(#2,#3)}
\newcommand{\Id}[1][]{\cfont{Id}_{#1}}
\newcommand{\Comp}{\cdot}
\newcommand{\NatTrans}[3]{#1 : #2 \Rightarrow #3}
\newcommand{\op}[1]{\ensuremath{{#1}^\text{op}}}
\newcommand{\inl}{\ensuremath{\iota_l}}
\newcommand{\inr}{\ensuremath{\iota_r}}
\newcommand{\projl}{\ensuremath{\pi_l}}
\newcommand{\projr}{\ensuremath{\pi_r}}
\newcommand{\intoproduct}[2]{\ensuremath{\langle #1, #2 \rangle}}
\newcommand{\outofcoproduct}[2]{\ensuremath{[ #1, #2 ]}}

\newcommand{\productmap}[2]{\ensuremath{ #1 \times #2 }}
\newcommand{\coproductmap}[2]{\ensuremath{ #1 + #2 }}
\newcommand{\rec}{\ensuremath{\mathsf{rec}}}

\newcommand{\Initalg}[1]{\ensuremath{\mu^{#1}}}
\newcommand{\Terminalcoalg}[1]{\ensuremath{\nu^{#1}}}
\newcommand{\Inv}[1]{#1 ^{-1}}
\newcommand{\catam}[1]{\llparenthesis #1 \rrparenthesis}
\newcommand{\anam}[1]{\llbracket #1 \rrbracket} % Different notation for anamorphisms which the author of the thesis uses, but I can't find the symbol which he uses. Actually it looks like he hardcoded [( )] which doesn't look nice. But this comes close to the notation I think.
\newcommand{\In}{\ensuremath{\mathsf{in}}}
\newcommand{\Out}{\ensuremath{\mathsf{out}}}

\newcommand{\nil}{\ensuremath{\mathsf{nil}}}
\newcommand{\cons}{\ensuremath{\mathsf{cons}}}


\newcommand{\co}[2]{\ensuremath{#2 \circ #1}}

\newcommand{\NN}{\ensuremath{\mathbb{N}}}
\newcommand{\Zero}{\ensuremath{\mathsf{zero}}}
\newcommand{\Succ}{\ensuremath{\mathsf{succ}}}

\newcommand{\Bool}{\ensuremath{\mathsf{Bool}}}
\newcommand{\QQ}{\ensuremath{\mathbb{Q}}}

\newcommand{\Leaf}[1]{\ensuremath{\mathsf{leaf}(#1)}}
\newcommand{\Branch}[2]{\ensuremath{\mathsf{branch}(#1, #2)}}

\newcommand{\Colist}{\ensuremath{\mathsf{Colist}}}
\newcommand{\Stream}{\ensuremath{\mathsf{Stream}}}
\newcommand{\tail}{\ensuremath{\mathsf{tail}}}
\newcommand{\head}{\ensuremath{\mathsf{head}}}
\newcommand{\nats}{\ensuremath{\mathsf{nats}}}
\newcommand{\zip}{\ensuremath{\mathsf{zip}}}
\newcommand{\map}{\ensuremath{\mathsf{map}}}
\newcommand{\filter}{\ensuremath{\mathsf{filter}}}

\newcommand{\const}{\ensuremath{\mathsf{const}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%opening
\title{Category Theory for Programming}
\author{Benedikt Ahrens \and Kobe Wullaert}
\date{}

\begin{document}

\maketitle

\vspace*{\fill}
We thank Csanád Farkas, Arnoud van der Leer, Niyousha Najmaei, and Pepijn Vunderink for their contributions to these notes.
\vspace*{\fill}


\noindent
This work is licensed under a Creative Commons \href{https://creativecommons.org/licenses/by-sa/4.0/}{``Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)''} license. \href{https://creativecommons.org/licenses/by-sa/4.0/}{\ccbysa}

\noindent
The source code for this document can be obtained from
\begin{center}
\url{https://github.com/benediktahrens/CT4P}.
\end{center}

\newpage

\paragraph*{Abstract}
In these lecture notes, we give a brief introduction to some elements of category theory.
The choice of topics is guided by applications to functional programming.
Firstly, we study initial algebras, which provide a mathematical characterization of datatypes and recursive functions on them.
Secondly, we study monads, which give a mathematical framework for effects in functional languages.
The notes include many problems and solutions.

\newpage
\tableofcontents
\newpage


\chapter{Introduction}

\section{About Category Theory}
\emph{Category theory} is a mathematical area of endeavour and language developed to reconcile and unify mathematical phenomena from different disciplines.
It was developed from the 1940s on, in particular by Samuel Eilenberg and Saunders Mac Lane.
Category theory studies objects by studying the way they interact with other objects of the same kind.
Its power arises from \emph{abstraction}:
by boiling down constructions to their essence, analogous situations can be formally identified using category theory.

The objects we can study using category theory are diverse;
while the origins of category theory lie in pure mathematics, it has now found applications throughout mathematics, computer science, and other areas of endeavor.
In these notes we introduce some basic concepts from category theory.
The choice of topics is guided by applications in the area of \emph{(functional) programming}; firstly, the structuring of effectful programs using \emph{monads} (see \cref{sec:monads}), and, secondly, the mathematical justification and derivation of \emph{recursion principles} such as \verb!fold! for the datatype of lists (see \cref{sec:initial-algs}).
We also study infinite datatypes (see \cref{sec:coinductive}).


\section{Learning Material on Category Theory}
\label{sec:material}


There are many topics of category theory not discussed in these notes.
Below, we list some resources that are freely available;
a very extensive list of resources is given at \url{https://www.logicmatters.net/categories/}.

\begin{itemize}
\item Pierce's book \cite{pierce} (available for free) gives a brief introduction to category theory with some applications to computing.

\item Leinster's book \cite{leinster} (available for free online, under a free license) gives a concise introduction to category theory.
It is a good resource for the basic concepts, but does not feature many examples from computer science.

\item The rather substantial textbook by Barr and Wells \cite{barr-wells} (available for free online) covers a lot more than we are going to discuss in these notes.

\item The Catsters \cite{catsters} provide a lecture series on category theory on YouTube.
  
\item A list of resources on category theory is maintained at \url{https://www.logicmatters.net/categories/}.
\end{itemize}

Throughout these notes, pointers to further sources, such as textbooks and research articles, are given.

\chapter{Brief Summary of Logical Foundations}
\label{sec:notation}

In these notes, we use set theory, \emph{informally}, as the language in which we define the concepts of category theory.
%Specifically, we talk about \emph{sets}, or \emph{collections}, of things.
%Given two sets $X$ and $Y$, we also talk about \emph{functions} from $X$ to $Y$.

\section{About set theory}

\begin{description}
\item [Sets/Collections] If $X$ is a set and $x$ is an element of $X$, we write $x \in X$.
  To define a set, we usually specify its elements, in an informal way.
  For instance, we consider the set $\NN$ of all natural numbers, with, e.g., $5 \in \NN$ and $37 \in \NN$.
  The set $\QQ$ is the set of all rational numbers, with, e.g., $2/3 \in \QQ$.

  We also consider a ``set of all sets''. Its elements are all sets.
  Here, we should be careful, as the set of all sets cannot be an element of itself; see the Barber paradox.\footnote{\url{https://en.wikipedia.org/wiki/Barber_paradox}}
  To fix this issue, we consider \emph{collections} in addition to \emph{sets};
  the ``set'' of all sets is not a set, but a collection instead.

  Of course, the collection of all collections gives rise to the same problem;
  so, when considering foundations of mathematics very formally, one usually has an infinite hierarchy of sets or collections (or types, e.g., in Martin-Löf type theory).
  
\item [Functions] If $X$ and $Y$ are sets, we can consider the set of functions from $X$ to $Y$. This set is denoted $X \to Y$. We write $f \in X \to Y$, but also $f : X \to Y$, to say that $f$ is a function from $X$ to $Y$.
  If $x \in X$, then $f(x) \in Y$ denotes the image of $x$ under $f$.
  When defining a function, we use the notation $x \mapsto f(x)$ to describe the image of $x$ under $f$. For instance, we define the function
  \begin{align*}
    \_/3 : \NN &\to \QQ
    \\
    n & \mapsto n/3
  \end{align*}
  This function takes as input a natural number, say, $n \in \NN$, and gives as output the rational number $n/3 \in \QQ$.
  
\item [Cartesian Product] Given two sets $X$ and $Y$, we can form a new set $X\times Y$, the \emph{(cartesian) product} of $X$ and $Y$. Its elements are pairs, written $(x,y)$, of an element $x \in X$ and $y \in Y$.
  For instance, we can write addition of natural numbers as a function
  \begin{align*}
    (+) : \NN\times \NN &\to \NN
    \\
    (m,n) & \mapsto m + n
  \end{align*}
\item[(Disjoint) Union] Given two sets $X$ and $Y$, we can form a new set $X + Y$, the disjoint union of $X$ and $Y$. Its elements are those of $X$ and those of $Y$, with information about whether an element ``comes from'' $X$ or $Y$. (To be more concrete, one could say that elements of $X+Y$ are of the form $(0,x)$ for $x\in X$ or $(1,y)$ for $y\in Y$.)
\end{description}

\section{About logic}

We also use logical connectives in the definition of categorical concepts.

\begin{description}
\item[Definitions] When we write $x := y$, we define a new mathematical object $x$ to be given by $y$.
  For instance, we could define a function doubling its input as follows:
  \begin{align*}
    \mathsf{double} &: \NN \to \NN
    \\
    \mathsf{double} &:=  x \mapsto x + x
  \end{align*}
  
\item[Equality] Given a set $X$ and $a,b\in X$, we can ask whether $a$ is equal to $b$; we write $a = b$ to assert that $a$ is equal to $b$.
  To \emph{prove} that two elements $a$ and $b$ of a set are equal, we have to understand what $a$ and $b$ are. For numbers $a$ and $b$, we intuitively know when they are equal.
  When proving that two functions $f, g : X \to Y$ are equal, we use the \emph{axiom of function extensionality}: to show that $f = g$, it suffices to show that for any possible input $x \in X$, the functions $f$ and $g$ agree on that input, that is, $f(x) = g(x)$.
  When showing that two monoid morphisms are equal, it suffices to show that their underlying functions are equal.
  When showing that two matrices are equal, it suffices to show that they are equal in each component.
\item [Implication]
  Given propositions $A$ and $B$, we write $A \implies B$ to say that $A$ implies $B$.
  
  More generally, if $X$ is a set and $P$ and $Q$ are predicates on $X$, we write $P\implies Q$ to express that if $P(x)$ holds for an element $x\in X$, then also $Q(x)$  holds for the element $x$.
  As an example, consider the predicates on natural numbers $n \in \NN$, ``$n$ is divisible by $4$'' and ``$n$ is even''.
  Then ``divisible by $4$'' $\implies$ ``is even''.

  Moreover, we write $P \iff Q$ if $P\implies Q$ and $Q\implies P$.
\item If $X$ is a set and $P$ is a predicate on $X$, we write:
\begin{description}
\item[forall] $\forall x\in X, P(x)$ to express that for every element in $X$, the property $P$ holds.
\item[exists] $\exists x\in X, P(x)$ to express that there exists at least one element in $X$ for which the property holds.
  For instance, consider the predicate
  \[  \mathsf{even}(n) := \exists k \in \NN, n = 2\times k.\]
\item[exists uniquely] $\exists! x\in X, P(x)$ to express that there exists a unique element in $X$ for which the property holds.
\end{description}
\end{description}

As an example, we can write the axiom of function extensionality as
\[ \big(\forall x \in X, f(x) = g(x)\big) \implies f = g \]


\section{About mathematical writing}

Mathematical text is typically structured into numbered ``environments'', for instance, ``definitions'', ``lemmas'', ``theorems'', and ``proofs''.
We briefly discuss each of these environments.

\begin{description}
\item[Definition] A definition introduces a new mathematical concept. You can think of a definition as an abbreviation, e.g., for a large structure consisting of many components.
  For instance, in \cref{dfn:category}, we define a category to be a structure consisting of objects, morphisms, etc.
  From then on, we use ``category'' as a shorthand for such a ``bundle'' of data satisfying the properties of a category.

  In the beginning, \textbf{it is important to learn definitions by heart.} Later, when you have understood the concepts well, you will be able to reproduce their definitions without explicitly learning them by heart.
\item[Example] An example is, usually, an instance of a definition. In \cref{example:set} (and \cref{lemma:set-category}), we look at specific data (sets and functions between them) and establish that they form a category.
\item[Lemma/Theorem/Proposition] All of these environments serve to formulate, precisely, a mathematical statement.
  The precise choice of environment signifies the status of the statement.
  A lemma is often of technical nature, a theorem is important, and a proposition is less important.
\item[Exercise] You are encouraged to think hard about every exercise in these notes. Some exercises are accompanied by solutions. It is worth first writing down your own solution, and then comparing it with the given solution.
\end{description}

\input{categories}

\input{morphisms}

\input{limits}

\input{functors}

\input{data}

\input{transformations}

\input{adjunctions}

\input{monads}


\chapter{Conclusions and Further Reading}

We have given a brief, and necessarily incomplete, introduction to category theory.
The choice of topics was guided by the applications to programming we considered.
 Here below, we list a few avenues for further exploration; this list is curated with a view towards pedagogy rather than scientific completeness.
\begin{itemize}
\item Altenkirch and Reus show how the lambda calculus forms a monad.
  (This can be generalized to other languages, including languages with simple types, see, e.g., \cite{DBLP:journals/jfrea/AhrensZ11}.)
\item For \emph{nested} datatypes, the iteration principle of \cref{sec:datatypes-as-initial} is often not enough; Bird and Paterson~\cite{DBLP:journals/fac/BirdP99} develop a \emph{generalized} fold operator for nested datatypes.
\item Some functions cannot be straightforwardly defined using the simple iteration scheme of \cref{sec:datatypes-as-initial}; for instance, the factorial function does not adhere to the required pattern.
  Vene~\cite{vene_phd} studies more general recursion schemes beyond the iteration (catamorphisms) of~\cref{sec:datatypes-as-initial}.
\item Harper~\cite{DBLP:phd/ethos/Harper13} develops a unifying framework for shortcut fusion.

\end{itemize}


\appendix


\input{solutions}


\input{forget-free}

\input{contravariant}

\printbibliography

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
